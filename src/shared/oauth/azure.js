import config from '@/config.js';
import { getOauthRedirectUrl, getOauthScopes, launchWebAuthFlow } from '@browsers/identity';
import oauthService from '@services/oauth.service';
import { logger } from '@utils/logger';
import { genShortRandomString } from '@utils/misc';

import { Buffer } from 'buffer';
import jwtDecode from 'jwt-decode';

const AZURE_OAUTH_ENDPOINT = 'https://login.microsoftonline.com';

const AZURE_OAUTH_AUTH_PATH = '/common/oauth2/v2.0/authorize';

const AZURE_OAUTH_ACESS_TOKEN_PATH = '/common/oauth2/v2.0/token';

const extractOauthAzureAuthCodeAndIdToken = ({ tokenResult }) => {
  const url = new URL(tokenResult);
  const searchParams = new URLSearchParams(url.hash.substr(1));
  const code = searchParams.get('code');
  const idToken = searchParams.get('id_token');
  return { code, idToken };
};

// See https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow
export const getOauthAzureAuthorization = async () => {
  const url = new URL(AZURE_OAUTH_AUTH_PATH, AZURE_OAUTH_ENDPOINT);
  url.searchParams.set('client_id', config.azureApiKey);
  url.searchParams.set('redirect_uri', getOauthRedirectUrl());
  url.searchParams.set('scope', getOauthScopes());
  url.searchParams.set('nonce', genShortRandomString()); // A value included in the request, generated by the app, that will be included in the resulting id_token as a claim
  url.searchParams.set('response_type', encodeURIComponent('code id_token')); // token: get access token, code: get authorization code, id_token: get id token
  url.searchParams.set('prompt', 'login'); // prompt=login claim forces the user to enter their credentials on that request
  url.searchParams.set('code_challenge', '6wSipUmgbbCIPHXq3tbcbBXth-e5XwpSjWYVl2hIWCE'); // Used to secure authorization code grants. Generate by https://tonyxu-io.github.io/pkce-generator/
  url.searchParams.set('code_challenge_method', 'S256'); // The method used to encode the code_verifier for the code_challenge parameter. This SHOULD be S256, but the spec allows the use of plain if the client can't support SHA256

  const decodedUrl = decodeURIComponent(url.toString());
  const tokenResult = await launchWebAuthFlow({ url: decodedUrl }); // Result is an url which format is "<redirect_uri>#code=<code>&id_token=<id_token>"
  return extractOauthAzureAuthCodeAndIdToken({ tokenResult });
};

// See https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-access-token-with-a-client_secret
// The response from azure server is { access_token: '...', id_token: '...', refresh_token: '...', scope: "openid email profile", expires_in: 3600, ext_expires_in: 3600, token_type: "Bearer" }
export const getOauthAzureAccessToken = async ({ code }) => {
  const searchParams = new URLSearchParams({
    code, // The authorization_code that acquired before
    client_id: config.azureApiKey,
    redirect_uri: getOauthRedirectUrl(), // The same redirect_uri value that was used to acquire the authorization_code
    grant_type: 'authorization_code', // Must be authorization_code for the authorization code flow.
    code_verifier: 'vocaboost0411', // Should match the original code_challenge
  });
  const payload = await fetch(`${AZURE_OAUTH_ENDPOINT}${AZURE_OAUTH_ACESS_TOKEN_PATH}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: searchParams, // This won't work: JSON.stringify({})
  }).then(resp => resp.json());
  return { accessToken: payload.access_token, idToken: payload.id_token, scope: payload.scope };
};

export const getAzureUserInfo = async ({ accessToken, idToken, scope }) => {
  const userData = jwtDecode(idToken);
  logger(`MS Oauth get user data result: ${JSON.stringify(userData)}`);

  const avatarBinary = await oauthService.getAzureUserPhoto({ accessToken });
  const avatarString = Buffer.from(avatarBinary, 'binary').toString('base64'); // Convert binary image to base64 string
  const avatar = `data:image/png;base64,${avatarString}`;
  return { ...userData, idToken, scope, avatar };
};
